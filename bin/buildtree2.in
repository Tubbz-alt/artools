#!/bin/bash
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

version=@version@

LIBDIR='@libdir@'
SYSCONFDIR='@sysconfdir@'
DATADIR='@datadir@'

[[ -r ${LIBDIR}/util-msg.sh ]] && source ${LIBDIR}/util-msg.sh
import ${LIBDIR}/util.sh
import ${LIBDIR}/util-pkg.sh

get_local_head(){
    echo $(git log --pretty=%H ...refs/heads/$1^ | head -n 1)
}

get_remote_head(){
    echo $(git ls-remote origin -h refs/heads/$1 | cut -f1)
}

is_dirty() {
    [[ $(git diff --shortstat 2> /dev/null | tail -n1) != "" ]] || return 1
    return 0
}

pull_tree(){
    local branch="master" tree="$1"
    local local_head=$(get_local_head "$branch")
    local remote_head=$(get_remote_head "$branch")
    local timer=$(get_timer)
    msg "Checking [%s] ..." "$tree"
    msg2 "local: %s" "${local_head}"
    msg2 "remote: %s" "${remote_head}"
    if [[ "${local_head}" == "${remote_head}" ]]; then
        info "nothing to do"
    else
        info "needs pull"
        git pull origin $branch
    fi
    msg "Done [%s]" "$tree"
    show_elapsed_time "${FUNCNAME}" "${timer}"
}

clone_tree(){
    local timer=$(get_timer) tree="$1" host_tree="$2"
    msg "Preparing [%s] ..." "$tree"
    info "clone"
    git clone $host_tree/$tree.git
    msg "Done [%s]" "$tree"
    show_elapsed_time "${FUNCNAME}" "${timer}"
}

pull_tree_arch(){
    cd ${tree_dir_arch}
        for tree in packages community;do
            if [[ -d ${tree} ]];then
                cd ${tree}
                    pull_tree "${tree}"
                cd ..
            else
                clone_tree "${tree}" "${host_tree_arch}/${tree}"
            fi
        done
    cd ..
}

pull_tree_artix(){
    local tree="$1"
    cd ${tree_dir_artix}
        if [[ -d ${tree} ]];then
            cd ${tree}
                git config --bool pull.rebase true
                pull_tree "${tree}"
            cd ..
        else
            clone_tree "${tree}" "${host_tree_artix}/${tree}"
        fi
    cd ..
}

read_import_list(){
    local tree="$1"
    local _space="s| ||g" _clean=':a;N;$!ba;s/\n/ /g' _com_rm="s|#.*||g"
    import_list=$(sed "$_com_rm" "${list_dir_import}/$tree.list" | sed "$_space" | sed "$_clean")
}

patch_pkg(){
    local pkg="$1"
    case $pkg in
        'glibc')
            sed -e 's|{locale,systemd/system,tmpfiles.d}|{locale,tmpfiles.d}|' \
                -e '/nscd.service/d' \
                -i $pkg/trunk/PKGBUILD
        ;;
        'bash')
            sed -e 's|system.bash_logout)|system.bash_logout\n        artix.bashrc)|' \
                -e 's|etc/bash.|etc/bash/|g' \
                -e 's|install -dm755 "$pkgdir"/etc/skel/|install -dm755 "$pkgdir"/etc/{skel,bash/bashrc.d}/|' \
                -e 's|/etc/skel/.bash_logout|/etc/skel/.bash_logout\n  install -m644 artix.bashrc "$pkgdir"/etc/bash/bashrc.d/artix.bashrc|' \
                -i $pkg/trunk/PKGBUILD

            patch -p1 -i $DATADIR/patches/artix-bash.patch

            cd $pkg/trunk
                updpkgsums
            cd ../..
        ;;
        'tp_smapi'|'acpi_call'|'r8168')
            sed -e 's|-ARCH|-ARTIX|g' -i $pkg/trunk/PKGBUILD
        ;;
    esac
}

get_import_path(){
    local tree="$1" import_path=
    case $tree in
        packages) import_path=${tree_dir_arch}/packages ;;
        packages-galaxy) import_path=${tree_dir_arch}/community ;;
    esac
    echo $import_path
}

find_repo(){
    local pkg="$1" repo=
    if [[ -d $pkg/repos/core-x86_64 ]];then
        repo=core-x86_64
    elif [[ -d $pkg/repos/core-any ]];then
        repo=core-any
    elif [[ -d $pkg/repos/extra-x86_64 ]];then
        repo=extra-x86_64
    elif [[ -d $pkg/repos/extra-any ]];then
        repo=extra-any
    elif [[ -d $pkg/repos/testing-x86_64 ]];then
        repo=testing-x86_64
    elif [[ -d $pkg/repos/testing-any ]];then
        repo=testing-any
    elif [[ -d $pkg/repos/staging-x86_64 ]];then
        repo=staging-x86_64  
    elif [[ -d $pkg/repos/staging-any ]];then
        repo=staging-any
    elif [[ -d $pkg/repos/community-x86_64 ]];then
        repo=community-x86_64
    elif [[ -d $pkg/repos/community-any ]];then
        repo=community-any
    elif [[ -d $pkg/repos/community-testing-x86_64 ]];then
        repo=community-testing-x86_64
    elif [[ -d $pkg/repos/community-testing-any ]];then
        repo=community-testing-any
    elif [[ -d $pkg/repos/community-staging-x86_64 ]];then
        repo=community-staging-x86_64
    elif [[ -d $pkg/repos/community-staging-any ]];then
        repo=community-staging-any
    elif [[ -d $pkg/repos/multilib-x86_64 ]];then
        repo=multilib-x86_64
    elif [[ -d $pkg/repos/multilib-testing-x86_64 ]];then
        repo=multilib-testing-x86_64
    elif [[ -d $pkg/repos/multilib-staging-x86_64 ]];then
        repo=multilib-staging-x86_64
    fi
    echo $repo
}

show_version_table(){
    local tree="$1" trunk="$2" node=
    declare -A UPDATES
    msg_table_header "%-30s %-30s %-30s %-30s" "Repository" "Package" "Artix version" "Arch version"
    for pkg in ${tree_dir_artix}/$tree/*; do
        
        local repo=$(find_repo "$pkg")
        node=repos/$repo
        if $trunk;then
            node=trunk
        fi
        if [[ -f $pkg/$node/PKGBUILD ]];then
            source $pkg/$node/PKGBUILD 2>/dev/null
            package=${pkg##*/}
            cd $pkg/$node
            artixver=$(get_full_version $package)
            local src=$(get_import_path "$tree" "$package")

            if [[ -f $src/$package/$node/PKGBUILD ]];then
                source $src/$package/$node/PKGBUILD 2>/dev/null
                cd $src/$package/$node
                archver=$(get_full_version $package)
            fi
            if [ $(vercmp $artixver $archver) -lt 0 ];then
                UPDATES[$package]="$pkg/$node/PKGBUILD $src/$package/$node/PKGBUILD"
                if $trunk;then
                    msg_row_update "%-30s %-30s %-30s %-30s" "${node}" "$package" "$artixver" "$archver"
                else
                msg_row_update "%-30s %-30s %-30s %-30s" "${repo%-*}" "$package" "$artixver" "$archver"
                fi
            fi
            unset pkgver epoch pkgrel artixver archver package
        fi
    done
    find "${patches_dir}/$tree/" -name *.patch -delete
    for upd in "${!UPDATES[@]}"; do
        msg "Writing %s update patch ..." "$upd"
        diff -u ${UPDATES[$upd]} > ${patches_dir}/$tree/"$upd"-archlinux.patch
    done
}

import_from_arch(){
    local timer=$(get_timer) tree="$1" trunk="$2"
    read_import_list "$tree"
    if [[ -n ${import_list[@]} ]];then
        cd ${tree_dir_artix}/$tree
        for pkg in ${import_list[@]};do
            local src=$(get_import_path "$tree")
            local dest=${tree_dir_artix}/$tree
            source $src/$pkg/trunk/PKGBUILD 2>/dev/null
            local ver=$(get_full_version $pkg)
            msg "Package: %s-%s" "$pkg" "$ver"
            if $trunk;then
                rsync "${rsync_args[@]}"  $src/$pkg/trunk/ $dest/$pkg/trunk/
                patch_pkg "$pkg"
            else
                rsync "${rsync_args[@]}"  $src/$pkg/repos/ $dest/$pkg/repos/
            fi

            unset pkgver epoch pkgrel ver
        done
    fi
    show_elapsed_time "${FUNCNAME}" "${timer}"
}

display_settings(){
    show_version
    show_config

    msg "OPTIONS:"
    msg2 "git_tree: %s" "${git_tree}"

    msg "ARGS:"
    msg2 "pull_artix: %s" "${pull_artix}"
    msg2 "pull_arch: %s" "${pull_arch}"
    msg2 "import_arch: %s" "${import_arch}"
    msg2 "trunk_only: %s" "${trunk_only}"

    msg "PATHS:"
    msg2 "tree_dir_artix: %s" "${tree_dir_artix}"
    msg2 "tree_dir_arch: %s" "${tree_dir_arch}"
    msg2 "patches_dir: %s" "${patches_dir}/${git_tree}"
}

load_user_info

load_config "${AT_USERCONFDIR}/artools.conf" || load_config "${SYSCONFDIR}/artools.conf"

pretend=false
pull_arch=false
pull_artix=false
import_arch=false
trunk_only=false
compare=false
move=false
git_tree='packages'

rsync_args=(-aWxvci --progress --delete-before --no-R --no-implied-dirs)

usage() {
    echo "Usage: ${0##*/} [options]"
    echo "    -r <git>      Git repo [default:${git_tree}]"
    echo "    -a            Pull arch tree"
    echo "    -b            Pull artix tree"
    echo '    -i            Import arch packages'
    echo '    -t            Import trunk only'
    echo '    -c            Compare packages'
    echo '    -q            Query settings'
    echo '    -h            This help'
    echo ''
    echo ''
    exit $1
}

orig_argv=("$0" "$@")

opts='r:abcitqh'

while getopts "${opts}" arg; do
    case "${arg}" in
        r) git_tree="$OPTARG" ;;
        a) pull_arch=true ;;
        b) pull_artix=true ;;
        i) import_arch=true ;;
        t) trunk_only=true ;;
        c) compare=true ;;
        q) pretend=true ;;
        h|?) usage 0 ;;
        *) echo "invalid argument '${arg}'"; usage 1 ;;
    esac
done

shift $(($OPTIND - 1))

prepare_dir "${tree_dir_artix}"
prepare_dir "${tree_dir_arch}"
prepare_dir "${patches_dir}/${git_tree}"

${pretend} && display_settings && exit 1

${pull_artix} && pull_tree_artix "${git_tree}"

${pull_arch} && pull_tree_arch

${compare} && show_version_table "${git_tree}" "$trunk_only"

${import_arch} && import_from_arch "${git_tree}" "$trunk_only"
